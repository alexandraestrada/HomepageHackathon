<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width">
		<link rel="stylesheet" href="./css/selection.css" type="text/css" media="all">
		<script type="text/javascript" charset="utf-8" src="./js/d3.min.js"></script>
		<title></title>
	</head>
	<body>
		<!-- inlining svg within html -->
		<svg width="325px" height="325px" xmlns="http://www.w3.org/2000/svg">
			  <path d=""/>
		</svg>
		<button class="undoBtn">undo</button>

		<script>
			var dsvg = d3.select('svg');
			var svg = document.querySelector('svg');
			var p = document.querySelector('path');
			var btn = document.querySelector('.undoBtn');

			function update(data) {
				// DATA JOIN
				// Join new data with old elements, if any.
				var circles = dsvg.selectAll("circle")
						.data(points);

				// UPDATE
				// Update old elements as needed.
				// circles.attr("class", "update");

				// ENTER
				// Create new elements as needed.
				circles.enter().append("circle")
					.attr('r', 10);

				// ENTER + UPDATE
				// Appending to the enter selection expands the update selection to include
				// entering elements; so, operations on the update selection after appending to
				// the enter selection will apply to both entering and updating nodes.
				// text.text(function(d) { return d; });
				circles.attr('cx', function(d) {return d.x;})
					.attr('cy', function(d) {return d.y;});

				// EXIT
				// Remove old elements as needed.
				circles.exit().remove();
			}


			// TODO undo feature
			var clicks = [];

			// Called when user starts adding path (first click, will add initial path)
			function startPath(x, y) {
				var currentPath = document.querySelector('.currentSelection');
				// var path = ['M', ' ', parseInt(x), ' ', parseInt(y)].join('');
				// points.push({x: parseInt(x), y: parseInt(y)});
				// currentPath.setAttribute('d', path);
			}

			// Add point to pathstring
			var points = [];
			function addPoint(path, x, y) {

				points.push({x: x, y: y});
				console.log(points);
				renderPoints(p, points)
			}


			function renderPoints(path, points) {
				if (points.length < 2 ) {
					path.setAttribute('d', '');
				} else {
					// Render start point string
					var startPntStr = "M" + parseInt(points[0].x) + ' ' + parseInt(points[0].y);

					// Render points string for rest of points.
					var pointsStr = points.slice(1).reduce(function(memo, point) {
						return memo + "L" + parseInt(point.x) + ' ' + parseInt(point.y) + ' ';
					}, '');
					console.log(pointsStr);


					// Concatanate points string w/ path string
					pathStr = [startPntStr, ' ', pointsStr, 'Z'].join('');
					console.log(pathStr);
					path.setAttribute('d', pathStr);
				}

				// Render circles as well
				// Consider using d3 selections, otherwise we have to manually remove the circles dom elements as well


				update(points);
			}

			svg.addEventListener('click', function(event) {
				// TODO
				// note: it seems clientX and clientY coordinates are not going to be relative to svg shape... need to fix this
				console.log(event);
				var bcr = this.getBoundingClientRect();
				addPoint(p, event.clientX - bcr.left, event.clientY - bcr.top);
			});

			// TODO
			// - is this needed?
			function endPath() {};


			function undo() {
				if (points.length === 0) {
					console.log("No more points to undo!");
					return;
				}
				points.pop();
				console.log(points);
				renderPoints(p, points);
			}

			btn.addEventListener('click', undo);



		</script>
	</body>
</html>
